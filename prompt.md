阶段 1：规则映射（1 个月）：
实现简单的指令到脚本映射，例如：• 指令“创建一个立方体” → bpy.ops.mesh.primitive_cube_add()。
• 使用 Python 字典或简单脚本存储映射关系。

make -j16 && /Users/yixin0909zhang/blender-git/build_darwin/bin/Blender.app/Contents/MacOS/Blender


/Users/yixin0909zhang/blender-git/build_darwin/bin/Blender.app/Contents/MacOS/Blender


发送给AI 变成 agent 建模规划
修复脚本错误 变成 agent 评估反思
执行脚本(类似Alt+P) agent 执行


修改代码的逻辑是，每次把代码请求 genimi ，genimi告诉你错误，你再针对性的修改，直到genimi 不再报错，然后执行脚本。




执行脚本过程中，如果遇到错误，需要提供错误信息，以便进行调试和修复。打印错误信息到控制台



程序一打开 ， Blender AI助手 的面板就是 打开的，且 始终在前端显示，一直显示再前端，任何操都不会隐藏 这个面板
只要4部分，
1. 标题： 保留Blender AI助手-智能助手
2. 用户需求记录区：记录多次请求的记录；保留 操作记录/信息输出区
3. 用户需求输入文本区，生成 执行blender python脚本 按钮；保留 输入栏+发送按钮
4. 增加 执行blenderpython脚本 按钮；




ai_gemini_integration.py  generate_blender_code 生成的代码有错，保存为 固定的文件名字；打印 这个文件里的内容；


点击 Blender AI助手 增加一个按钮 ，用户执行这个按钮，ai_gemini_integration.py  generate_blender_code 生成的代码有错，保存为 固定的文件名字；
就会执行这固定的文件名字；



点击 Blender AI助手  后， 下拉框agent模式要一直显示界面上，能够让用户持续输入自己想要对产生的模型的修改；
只有再次点击 Blender AI助手 后 下拉框agent模式才会隐藏；
代码修改完成后，你写一个单元测试，你检查一下，用户是否可以连续输入，不用重复点击 Blender AI助手 ；
在blender中要让一个面板始终在前端显示，可以尝试一下方法。一检查面板锁定选项有些面板有锁定选项，通常在面板的右上角有一个图钉图标点击这个图标可以锁定面板，使其不会被其他操作隐藏。二使用Python脚本如果有编程能力，你可以编写一个简单的blender Python脚本，通过脚本来控制面板的显示和位置。

程序一打开 ， Blender AI助手 的面板就是 打开的，且 始终在前端显示，一直显示再前端，任何操都不会隐藏 这个面板


点击 Blender AI助手  后，下拉框agent模式 ，保证下拉框agent模式 的宽度是固定的，长度是可变的；
并且下拉框agent模式 ，的长度是根据用户输入的内容的长度来动态变化的；



为一个名为「{{角色名}}」的卡通角色创建完整 3D 模型，要求如下：

1. **整体风格**：
   - 采用卡通风格，适合动画或 3D 打印。
   - 外观造型简洁夸张，强调拟人化与可爱感。

2. **部件构成**（以下结构应作为基本组成）：
   - **头部**：一个{{头部形状，如“球体”}}，作为角色主要结构，放置在中心位置。
   - **耳朵**：两个{{耳朵形状，如“小球体”}}，对称分布在头部左右上方。
   - **眼睛**：两个{{眼睛形状，如“球体”}}，位于头部前方，对称分布。
   - **嘴巴**：一个{{嘴巴形状，如“甜甜圈”}}，位于头部下部中央，表现嘴部结构。
   - **手臂**：两个{{手臂形状，如“细长圆柱体”}}，从身体两侧延伸，位置自然。
   - **腿部**：两个{{腿部形状，如“较粗圆柱体”}}，位于身体底部用于支撑角色。
   - **配件（可选）**：
     - 背包、帽子、尾巴、胡子等附加部件，可增强角色个性。
     - 比如帽子使用一个上半球，背包使用一个缩放后的立方体。

3. **比例要求**：
   - 各部件位置、大小比例协调，符合视觉美感与结构合理性。

4. **脚本功能要求**：
   - 所有建模结构用 Blender Python API 实现，使用原始几何体。
   - 添加 `log()` 函数记录每一步构建进程。
   - 使用 `join()` 将所有模型合并为单一对象，命名为角色名。
   - 不使用 `bpy.ops.object.select_all(action='SELECT')` 清空场景，以防影响现有模型。





• 阶段 2：引入 AI（2 个月）：
• 使用现有 LLM（如 GPT-4 或开源模型 Llama）通过 API 生成 Blender 脚本，参考 Blender Tutorial with ChatGPT.
• 如果资源允许，fine-tune 小型模型（如基于 BlendNet 数据集 (Hugging Face BlendNet)).

• 阶段 3：反馈机制（1-2 个月）：
• 软件错误反馈：检测脚本语法或运行时错误，优化生成（如 BlenderLLM 的错误率仅 3.4%）。
• 结构力学反馈：集成 Blender 的有限元分析插件（如 BlenderFEA）或外部工具（如 PyNite）验证模型物理正确性。



点击Blender AI助手3D Moder Copilot主面板后，发送按钮 左边的默认的输入内容，为： 设计一个鼻炎吸鼻器：

三部分组成，一个盒子是洗鼻器的主体，包含电机等，

可拆卸的部分1，能加入0.9%的生理盐水胶囊，像装子弹一样装上；

可拆卸的部分2 ，带走废液，倒掉；像卸载子弹一样卸载；
：

点击 发送后 将自然语言指令转化为Blender可执行的鼠标点击操作，并且鼠标点击操作变成API函数调用。
把点击操作和 ，API 调用的函数，输出到log中，print出来


log 打印出来了，但是没有 实现类似人的鼠标点击，在blender的主界面用户视角没有显示出来，我需要的3d模型：


点击Blender AI助手3D Moder Copilot主面板后  变成连续对话模式，先查看一下 操作记录/信息输出区 是在哪里实现的； 上一次的输入的命令 显示在操作记录/信息输出区，并且能保留下来，并且能进行刷新；



Blender AI助手 按钮 ，打开程序时，就一直显示在哪里，点击后，下拉框一直显示，点击发送后，依然显示，现在是隐藏了；点击发送按钮后，Blender AI助手 按钮 ，下拉框一直保持在界面上，并且能一直显示；



第一步，生成的模型太抽象，需要进行连续对话，进行细化；后续输入的内容，如何被大模型 进行理解，细化成更加精细的api 调用；

使用blender 

设计一个鼻炎吸鼻器：三部分组成，一个盒子是洗鼻器的主体，包含电机等，可拆卸的部分1，能加入0.9%的生理盐水胶囊，像装子弹一样装上，可拆卸的部分2 ，带走废液，倒掉；像卸载子弹一样卸载；   能够量产的设备3d模型设计： 

第一步应该 点击什么按钮，调用那个函数，第二步，应该点击什么调用什么函数，列出100步操作应该调用的函数


如果我用 ai agent的思想，记忆，规划，行动，调用工具来完成整个产品设计和建模，我应该如何做？



项目进展 ： 基于blender的 项目，开发了一个按钮 ai assitant ，能够输入用户的要求，支持连续对话，但是 理解用户的要求，把用户在文本框中输入的文字变成 专业建模专家的鼠标点击，以及调用 对应点击的API不太对，建模出来的模型，完全不满足 精细度要求，外观上只有 cube，无法完成把鼻涕吸出来的功能；



10. 点击：布尔修改器 > Operation > Difference函数：bpy.context.object.modifiers["Boolean"].operation = 'DIFFERENCE'说明：挖空盒子内部。

结构上连接合理、外观上协调统一的整体模型



# 通用 Blender Python API 任意 3D 模型生成 Prompt（含几何与力学分析）

## 目标
根据用户在文本框输入的任意 3D 模型需求，使用 Google Gemini API 生成 Blender Python API 代码，创建满足多学科约束（物理、生物、化学、政治、经济、文化、系统学）的 3D 模型，适合 3D 打印，部件间正确连接。代码需包含几何分析（壁厚、悬空角度、部件连接）和力学分析（重心、应力分布），可在 Blender 中直接执行，生成完整模型。

## 输入
- **用户输入**：文本框中的自然语言描述，说明所需的 3D 模型嗯。
- **可选参数**：
  - 目标地区（用于政治/文化约束，默认：通用）。
  - 材料偏好（默认：PLA）。
  - 尺寸（例如：以米为单位）。
  - 预算限制（例如：材料成本上限）。
  - 文化偏好（例如：“中国市场，偏好红色”）。

## 要求
1. **触发机制**：用户点击“发送”按钮后，读取文本框输入，使用 Google Gemini API（API 密钥：`AIzaSyC5zCgXXwCNbUR_phRtmciRSBrCcDqg`）生成 Blender Python 代码。
2. **API 集成**：
   - 使用 `gemini-2.0-flash` 模型，通过 `client.models.generate_content` 调用。
   - 将用户输入和约束条件传入 Prompt，生成代码。
3. **代码功能**：
   - 根据用户需求动态创建模型部件。
   - 实现连接机制（例如：螺丝、卡扣，使用 `bpy.ops.mesh` 进行布尔运算）。
   - 执行几何分析和力学分析（详见下文）。
   - 将所有部件合并为单一对象（`join_all_objects`）。
4. **代码风格**：
   - 模块化结构，包含以下函数：`log(message)`、`check_mechanics()` 等。
   - 每一步操作需记录日志（例如：`[Log] 创建部件 X`）。
   - 参考以下格式：
     ```
     import bpy
     def log(message):
         print(f"[Log] {message}")
     def create_component():
         bpy.ops.mesh.primitive_cube_add()
     def join_all_objects():
         bpy.ops.object.join()
     def build_model():
         create_component()
         join_all_objects()
     ```
5. **模型命名**：从用户输入中提取模型名称（例如：“桌子” → `Table`）。

## 多学科约束
1. **物理（力学）**：
   - **重心稳定性**：确保模型重心位于基底上方（使用 `mathutils.Vector` 和部件体积计算）。
   - **应力分布**：计算典型负载下的应力（例如：家具 50kg），使用 `mathutils` 处理力向量。
   - **3D 打印适配性**：
     - 最小壁厚：1.2 毫米。
     - 无超过 45 度的悬空部分（或需支撑）。
     - 底面平整以贴合打印床。
   - **运动学**：若涉及关节，需支持指定运动范围（例如：铰链 0-180 度，使用 `bpy.types.Object.constraints`）。
2. **生物**：
   - **人体工学**：若涉及人体使用，形状需符合人体解剖学（例如：手柄曲线，使用 `bpy.ops.curve`）。
   - **生物相容性**：材料需无毒（例如：医疗用途选用 PLA）。
   - **重量**：可穿戴设备总重低于 1 公斤（使用 `bpy.data.objects` 计算体积和材料密度）。
3. **化学**：
   - **材料稳定性**：抗腐蚀（例如：室外使用选用 ABS）。
   - **打印材料**：适配 3D 打印（例如：PLA 密度 1.24 g/cm³，熔点 180°C）。
   - **表面处理**：表面光滑以避免化学残留（使用 `bpy.ops.object.modifier_add(type='SUBSURF')`）。
4. **政治**：
   - **法规合规**：符合目标地区法规（例如：欧盟需 CE 认证）。
   - **知识产权**：避免受专利保护的设计。
   - **政治中立**：避免使用敏感符号或形状。
5. **经济**：
   - **材料效率**：尽量减少材料用量（使用 `bpy.data.meshes` 优化多边形数量）。
   - **成本控制**：材料成本低于 10 美元/公斤（例如：PLA 每克 0.02 美元）。
   - **可扩展性**：设计适于批量生产（例如：部件可堆叠）。
6. **文化**：
   - **美学**：符合目标文化偏好（例如：中国市场偏好红色）。
   - **文化敏感性**：避免文化禁忌（例如：某些宗教符号）。
   - **用户体验**：考虑目标群体的文化习惯（例如：儿童玩具需色彩鲜艳）。
7. **系统学**：
   - **整体协调**：部件间无缝连接（例如：互锁设计）。
   - **模块化**：支持部件替换或升级。
   - **鲁棒性**：在多种使用场景下保持功能（例如：不同负载下稳定）。

## 几何分析算法
1. **壁厚检测**：
   - 使用 `bpy.data.meshes` 分析网格几何。
   - 对每个网格，计算相对面之间的最小距离（例如：使用光线投射或顶点邻近分析）。
   - 确保壁厚 ≥ 1.2 毫米；若不满足，应用 `bpy.ops.object.modifier_add(type='SOLIDIFY')` 加厚。
   - 记录日志（例如：`[Log] 部件 X 壁厚：1.5 毫米`）。
2. **悬空角度检测**：
   - 使用 `mathutils.geometry` 计算面法线。
   - 识别相对于打印床（Z 轴）角度 > 45 度的面。
   - 若检测到悬空，添加支撑结构（例如：使用 `bpy.ops.mesh.primitive_cylinder_add` 创建支撑柱）或调整几何。
   - 记录日志（例如：`[Log] 部件 X 悬空角度：30 度`）。
3. **部件连接检查**：
   - 对每对部件，验证接触面是否存在（例如：使用 `bpy.ops.object` 进行布尔交集检查）。
   - 确保部件通过互锁或标准连接件（例如：卡扣、螺丝）连接。
   - 记录日志（例如：`[Log] 部件 X 与部件 Y 已连接`）。

## 力学分析约束
1. **重心稳定性**：
   - 使用 `mathutils.Vector` 计算重心：
     - 对所有部件，计算质量（体积 × 密度，例如：PLA 1.24 g/cm³），体积通过 `mesh.calc_volume()` 获取。
     - 计算质量加权位置之和，得到重心。
   - 确保重心位于基底上方（Z > 0）。
   - 记录日志（例如：`[Log] 重心位置：(0.1, 0.2, 0.3)`）。
2. **应力分布**：
   - 模拟典型负载下的应力（例如：家具 50kg 垂直力）。
   - 使用 `mathutils` 计算力向量并分配到部件。
   - 识别高应力区域（例如：薄壁部分），通过加厚或添加支撑强化。
   - 记录日志（例如：`[Log] 部件 X 最大应力：10 MPa`）。
3. **负载能力**：
   - 确保模型支持指定负载（例如：家具 50kg，可穿戴设备 10kg）。
   - 若负载能力不足，调整几何（例如：加厚支撑结构）。
   - 记录日志（例如：`[Log] 部件 X 负载能力：60kg`）。

## 验证
- **力学检查**：调用 `check_mechanics()` 验证重心和应力分布。
- **物理检查**：调用 `check_physics()` 验证壁厚和悬空角度。
- **外观检查**：调用 `check_appearance()` 确保符合文化偏好。
- **结构检查**：调用 `check_structure()` 确认部件连接。
- 记录验证结果（例如：`[Log] 力学检查通过`）。

## 输出
- **Blender Python 代码**：
  - 完整、可执行的代码，包含模块化函数。
  - 导入必要模块（`bpy`、`mathutils`、`math`）。
  - 根据用户需求动态生成部件。
  - 实现几何和力学分析。
- **执行流程**：
  - 代码在 Blender 中运行，生成模型，验证约束。
  - 每一步记录日志，便于调试（例如：`[Log] 部件已经创建完成`）。

## 注意事项
- 若用户输入未提供细节（例如：目标地区），默认使用通用法规和 PLA 材料。
- 若需求复杂（例如：多关节系统），生成模块化代码，逐一验证。
- 几何分析（壁厚、悬空）需精确网格分析，复杂模型可能需性能优化。
- 力学分析为简化模拟，高级仿真（如有限元分析）需外部工具。
- 确保 Gemini API 密钥有效。
- 若需生成渲染图像（例如：模型预览），需用户确认后使用 `bpy.ops.render`。
- 若需可视化力学分析（例如：重心分布图），需用户确认后使用 Canvas 面板生成图表。





实现逻辑改一下：
用户在点击发送按钮后，读取 文本框的需求文字，使用大模型 google gemini 
api key = AIzaSyC5zCgXXwCNbUmbQR_phRtmciRSBrCcDqg

prompt ： 读取 文本框的需求：根据 blender python API的格式，生成对应的blender python代码；
代码中 检测 力学原理，检测 物理原理，检测 外观，检测 结构；

生成的代码， 能够直接在 blender 中执行，生成3d模型；


{from google import genai

client = genai.Client(api_key="YOUR_API_KEY")

response = client.models.generate_content(
    model="gemini-2.0-flash",
    contents="读取 文本框的需求：根据 blender python API的需求，生成对应的blender python代码",
)

print(response.text)

}转换成  类似下面的blender的python 代码，只参考格式，不参考内容：
{
import bpy
import math

省略具体逻辑，但是你要生成

def build_character():
    start_log()
    clear_scene()
    create_head()
    add_ears()
    add_eyes()
    add_mouth()
    add_arms()
    add_legs()
    add_backpack()
    add_hat()
    join_all_objects()
    end_log()

# 执行
build_character()
}

你可以把这段代码粘贴到 Blender 脚本编辑器中执行，看到完整角色模型。

然后 直接在 blender 中执行 生成的代码，生成模型；