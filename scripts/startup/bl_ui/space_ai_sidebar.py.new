import bpy
import os
import sys
import json
import re
import time
import traceback
from bpy.types import Panel, UIList, PropertyGroup, Operator
from bpy.props import StringProperty, BoolProperty, IntProperty, CollectionProperty, PointerProperty

# 获取当前脚本所在目录
script_dir = os.path.dirname(os.path.abspath(__file__))

# 配置文件路径
CONFIG_FILE = os.path.join(script_dir, "..", "ai_config.json")

# 默认配置
DEFAULT_CONFIG = {
    "default_prompts": {
        "placeholder_short": "为一个名为「小兔子」的卡通角色创建完整3D模型，包含头部、耳朵、眼睛、嘴巴、手臂、腿部和尾巴等结构...",
    }
}

# 加载配置
def load_config():
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
            print(f"已加载配置文件: {CONFIG_FILE}", flush=True)
            return config
        else:
            print(f"配置文件不存在，使用默认配置: {CONFIG_FILE}", flush=True)
            return DEFAULT_CONFIG
    except Exception as e:
        print(f"加载配置文件时出错: {e}", flush=True)
        return DEFAULT_CONFIG

# 全局配置对象
CONFIG = load_config()

# 重新加载配置
def reload_config():
    global CONFIG
    CONFIG = load_config()
    return CONFIG

# 调试函数
def debug_ai_assistant():
    print("\n==== AI Assistant Debug Info ====", flush=True)
    print(f"Script directory: {script_dir}", flush=True)
    print(f"Config file: {CONFIG_FILE}", flush=True)
    print(f"Config loaded: {CONFIG}", flush=True)
    
    # 检查属性组是否已注册
    if hasattr(bpy.types.Scene, "ai_assistant"):
        print("ai_assistant property is registered", flush=True)
        
        # 检查当前场景是否有ai_assistant属性
        if hasattr(bpy.context.scene, "ai_assistant"):
            print("Current scene has ai_assistant property", flush=True)
            print(f"keep_open: {bpy.context.scene.ai_assistant.keep_open}", flush=True)
            print(f"message: {bpy.context.scene.ai_assistant.message}", flush=True)
            print(f"messages count: {len(bpy.context.scene.ai_assistant.messages)}", flush=True)
        else:
            print("Current scene does NOT have ai_assistant property", flush=True)
    else:
        print("ai_assistant property is NOT registered", flush=True)
    
    # 检查操作符是否已注册
    ops = [
        "ai.send_message",
        "ai.clear_history",
        "ai.set_mode",
        "ai.initialize",
        "ai.debug",
    ]
    
    for op in ops:
        if hasattr(bpy.ops, op.split(".")[0]) and hasattr(getattr(bpy.ops, op.split(".")[0]), op.split(".")[1]):
            print(f"Operator {op} is registered", flush=True)
        else:
            print(f"Operator {op} is NOT registered", flush=True)

# 消息项类
class AIMessageItem(PropertyGroup):
    text: StringProperty(
        name="消息内容",
        description="消息的文本内容",
        default=""
    )
    is_user: BoolProperty(
        name="是否为用户消息",
        description="如果为True，则表示这是用户发送的消息；否则是AI的回复",
        default=False
    )

# AI助手属性组
class AIAssistantProperties(PropertyGroup):
    message: StringProperty(
        name="消息",
        description="要发送给AI的消息",
        default=""
    )
    messages: CollectionProperty(
        type=AIMessageItem,
        name="消息历史",
        description="与AI的对话历史"
    )
    active_message_index: IntProperty(
        name="活动消息索引",
        description="当前选中的消息索引",
        default=0
    )
    mode: StringProperty(
        name="模式",
        description="AI助手的模式",
        default="agent"
    )
    keep_open: BoolProperty(
        name="保持打开",
        description="保持AI Assistant面板打开",
        default=False
    )

# 消息列表UI
class AI_UL_messages(UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            row = layout.row()
            if item.is_user:
                row.label(text=f"[User] {item.text}", icon='USER')
            else:
                row.label(text=f"[AI] {item.text}", icon='COMMUNITY')
        elif self.layout_type in {'GRID'}:
            layout.alignment = 'CENTER'
            layout.label(text="", icon='USER' if item.is_user else 'COMMUNITY')

# 设置模式操作符
class AI_OT_set_mode(Operator):
    bl_idname = "ai.set_mode"
    bl_label = "设置模式"
    bl_description = "设置AI助手的模式"
    
    mode: StringProperty(
        name="模式",
        description="要设置的模式",
        default="agent"
    )
    
    def execute(self, context):
        if hasattr(context.scene, "ai_assistant"):
            context.scene.ai_assistant.mode = self.mode
            self.report({'INFO'}, f"已切换到{self.mode}模式")
        return {'FINISHED'}

# 发送消息操作符
class AI_OT_send_message(Operator):
    bl_idname = "ai.send_message"
    bl_label = "发送消息"
    bl_description = "向AI发送消息"
    
    def execute(self, context):
        if not hasattr(context.scene, "ai_assistant"):
            self.report({'ERROR'}, "AI Assistant尚未初始化")
            return {'CANCELLED'}
        
        ai_props = context.scene.ai_assistant
        message = ai_props.message.strip()
        
        if not message:
            self.report({'ERROR'}, "消息不能为空")
            return {'CANCELLED'}
        
        # 添加用户消息到历史记录
        user_msg = ai_props.messages.add()
        user_msg.text = message
        user_msg.is_user = True
        
        # 清空输入框
        ai_props.message = ""
        
        # 确保面板保持打开
        ai_props.keep_open = True
        
        # 强制刷新UI
        for area in context.screen.areas:
            area.tag_redraw()
        
        # 处理消息
        try:
            # 导入Gemini集成模块
            import ai_gemini_integration
            
            # 根据模式处理消息
            if ai_props.mode == "agent":
                # Agent模式：发送消息到Gemini
                response = ai_gemini_integration.send_message_to_gemini(message)
                
                # 添加AI回复到历史记录
                ai_msg = ai_props.messages.add()
                ai_msg.text = response
                ai_msg.is_user = False
                
                # 如果消息包含代码生成请求，尝试生成代码
                if any(keyword in message.lower() for keyword in ["创建", "生成", "制作", "建模", "模型", "3d", "三维"]):
                    try:
                        ai_gemini_integration.generate_blender_code(message)
                    except Exception as e:
                        self.report({'ERROR'}, f"生成代码时出错: {str(e)}")
                        print(f"生成代码时出错: {str(e)}", flush=True)
                        print(traceback.format_exc(), flush=True)
            else:
                # 未知模式
                self.report({'ERROR'}, f"未知模式: {ai_props.mode}")
                return {'CANCELLED'}
            
            self.report({'INFO'}, "指令已处理")
        except ImportError as e:
            self.report({'ERROR'}, f"无法导入AI集成模块: {str(e)}")
            return {'CANCELLED'}
        except Exception as e:
            self.report({'ERROR'}, f"处理消息时出错: {str(e)}")
            print(f"处理消息时出错: {str(e)}", flush=True)
            print(traceback.format_exc(), flush=True)
            return {'CANCELLED'}
        
        return {'FINISHED'}

# 清除历史操作符
class AI_OT_clear_history(Operator):
    bl_idname = "ai.clear_history"
    bl_label = "清除历史"
    bl_description = "清除对话历史"
    
    def execute(self, context):
        if hasattr(context.scene, "ai_assistant"):
            context.scene.ai_assistant.messages.clear()
            self.report({'INFO'}, "对话历史已清除")
        return {'FINISHED'}

# 刷新历史操作符
class AI_OT_refresh_history(Operator):
    bl_idname = "ai.refresh_history"
    bl_label = "刷新历史"
    bl_description = "刷新对话历史显示"
    
    def execute(self, context):
        # 强制刷新UI
        for area in context.screen.areas:
            area.tag_redraw()
        self.report({'INFO'}, "历史显示已刷新")
        return {'FINISHED'}

# 重新加载配置文件操作符
class AI_OT_reload_config(Operator):
    bl_idname = "ai.reload_config"
    bl_label = "重新加载配置"
    bl_description = "重新加载AI助手配置文件"
    
    def execute(self, context):
        try:
            reload_config()
            self.report({'INFO'}, "配置文件已重新加载")
        except Exception as e:
            self.report({'ERROR'}, f"重新加载配置文件时出错: {str(e)}")
            return {'CANCELLED'}
        return {'FINISHED'}

# AI助手面板
class VIEW3D_PT_ai_assistant(Panel):
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "scene"
    bl_label = "AI Assistant"
    bl_options = {'DEFAULT_CLOSED'}
    
    def draw(self, context):
        layout = self.layout
        
        # Check if the property group is registered
        if not hasattr(context.scene, "ai_assistant"):
            layout.label(text="AI Assistant not initialized yet.")
            layout.label(text="Please restart Blender.")
            
            # Try to register the property group
            row = layout.row()
            row.operator("ai.initialize", text="Initialize AI Assistant", icon='FILE_REFRESH')
            return
        
        ai_props = context.scene.ai_assistant
        
        # 模式选择
        row = layout.row()
        row.label(text="Mode:")
        row.operator("ai.set_mode", text="Agent", icon='COMMUNITY').mode = "agent"

# AI助手输入面板
class VIEW3D_PT_ai_assistant_input(Panel):
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "scene"
    bl_label = "AI Input"
    bl_parent_id = "VIEW3D_PT_ai_assistant"
    bl_options = {'INSTANCED'}
    bl_ui_units_x = 80  # 增加宽度
    bl_ui_units_y = 60  # 增加高度
    
    def draw(self, context):
        layout = self.layout
        
        # Check if the property group is registered
        if not hasattr(context.scene, "ai_assistant"):
            layout.label(text="AI Assistant not initialized yet.")
            layout.label(text="Please restart Blender.")
            
            # Try to register the property group
            row = layout.row()
            row.operator("ai.initialize", text="Initialize AI Assistant", icon='FILE_REFRESH')
            return
        
        ai_props = context.scene.ai_assistant
        
        # 1. 标题：Blender AI 助手
        title_box = layout.box()
        title_row = title_box.row()
        title_row.scale_y = 1.5
        title_row.label(text="Blender AI 助手", icon='COMMUNITY')
        
        # 2. 用户需求记录区
        log_box = layout.box()
        log_title = log_box.row()
        log_title.scale_y = 1.2
        log_title.label(text="用户需求记录", icon='TEXT')
        
        # 显示历史对话记录
        log_content = log_box.box()
        log_content.scale_y = 1.0
        
        if hasattr(ai_props, "messages") and len(ai_props.messages) > 0:
            # 最多显示最近的8条消息
            start_idx = max(0, len(ai_props.messages) - 8)
            
            for i in range(start_idx, len(ai_props.messages)):
                msg = ai_props.messages[i]
                msg_row = log_content.row()
                
                if msg.is_user:
                    msg_row.label(text=f"[User] {msg.text[:60]}{'...' if len(msg.text) > 60 else ''}")
                else:
                    msg_row.label(text=f"[AI] {msg.text[:60]}{'...' if len(msg.text) > 60 else ''}")
        else:
            # 如果没有历史消息，不显示任何默认内容
            pass
        
        # 3. 输入文本区和发送按钮
        input_box = layout.box()
        input_row = input_box.row()
        
        # 输入框
        input_col = input_row.column()
        input_col.scale_y = 2.0
        input_col.scale_x = 5.0
        # 从配置文件读取占位符文本
        placeholder_text = CONFIG.get("default_prompts", {}).get(
            "placeholder_short",
            "为一个名为「小兔子」的卡通角色创建完整3D模型，包含头部、耳朵、眼睛、嘴巴、手臂、腿部和尾巴等结构...",
        )
        
        input_col.prop(
            ai_props,
            "message",
            text="",
            placeholder=placeholder_text,
        )
        
        # 发送按钮
        send_col = input_row.column()
        send_col.scale_x = 1.0
        send_col.scale_y = 2.0
        send_col.operator("ai.send_message", text="发送", icon='PLAY')

# 添加切换AI Assistant面板显示的操作符
class AI_OT_toggle_panel(bpy.types.Operator):
    bl_idname = "ai.toggle_panel"
    bl_label = "切换AI Assistant面板"
    bl_description = "切换AI Assistant面板的显示状态"
    bl_options = {'REGISTER'}
    
    def execute(self, context):
        # 切换keep_open属性
        if hasattr(context.scene, "ai_assistant"):
            context.scene.ai_assistant.keep_open = not context.scene.ai_assistant.keep_open
            
            # 强制刷新UI
            for area in context.screen.areas:
                area.tag_redraw()
                
            status = "打开" if context.scene.ai_assistant.keep_open else "关闭"
            self.report({'INFO'}, f"AI Assistant面板已{status}")
        else:
            self.report({'ERROR'}, "AI Assistant尚未初始化")
            return {'CANCELLED'}
        return {'FINISHED'}

# 添加运行单元测试的操作符
class AI_OT_run_tests(bpy.types.Operator):
    bl_idname = "ai.run_tests"
    bl_label = "运行单元测试"
    bl_description = "运行 AI Assistant 功能的单元测试"
    bl_options = {'REGISTER'}
    
    def execute(self, context):
        try:
            import test_ai_assistant
            
            test_ai_assistant.run_tests()
            self.report({'INFO'}, "单元测试已完成，请查看控制台输出")
        except ImportError as e:
            self.report({'ERROR'}, f"无法导入测试模块: {str(e)}")
            return {'CANCELLED'}
        except Exception as e:
            self.report({'ERROR'}, f"运行测试时出错: {str(e)}")
            return {'CANCELLED'}
        return {'FINISHED'}

# Initialize AI Assistant operator
class AI_OT_initialize(bpy.types.Operator):
    bl_idname = "ai.initialize"
    bl_label = "Initialize AI Assistant"
    bl_description = "Initialize the AI Assistant property group"
    
    def execute(self, context):
        print("\n==== Initializing AI Assistant ====", flush=True)
        
        # Make sure the property class is registered
        try:
            if AIAssistantProperties not in bpy.utils.bl_rna_get_subclasses(bpy.types.PropertyGroup):
                bpy.utils.register_class(AIAssistantProperties)
                print("Registered AIAssistantProperties class", flush=True)
        except Exception as e:
            self.report({'ERROR'}, f"Failed to register property class: {e}")
            print(f"Error registering AIAssistantProperties: {e}", flush=True)
            return {'CANCELLED'}
        
        # Register the property group
        try:
            if not hasattr(bpy.types.Scene, "ai_assistant"):
                bpy.types.Scene.ai_assistant = bpy.props.PointerProperty(type=AIAssistantProperties)
                print("Registered ai_assistant property", flush=True)
        except Exception as e:
            self.report({'ERROR'}, f"Failed to register property group: {e}")
            print(f"Error registering ai_assistant property: {e}", flush=True)
            return {'CANCELLED'}
        
        # Initialize the property values
        try:
            context.scene.ai_assistant.keep_open = True
            context.scene.ai_assistant.message = ""
            print("Initialized ai_assistant properties", flush=True)
        except Exception as e:
            self.report({'ERROR'}, f"Failed to initialize properties: {e}")
            print(f"Error initializing properties: {e}", flush=True)
            return {'CANCELLED'}
        
        self.report({'INFO'}, "AI Assistant initialized successfully")
        return {'FINISHED'}

# Debug operator with breakpoint
class AI_OT_debug(bpy.types.Operator):
    bl_idname = "ai.debug"
    bl_label = "Debug AI"
    bl_description = "Debug the AI Assistant (sets breakpoint)"
    
    def execute(self, context):
        print("\n==== AI Assistant Debug Breakpoint ====", flush=True)
        print("Setting breakpoint...", flush=True)
        sys.stdout.flush()
        
        # This will definitely trigger a breakpoint
        import pdb
        
        pdb.set_trace()
        
        # Create debug variables
        import builtins
        
        builtins.ai_debug_context = context
        builtins.ai_debug_self = self
        
        # Call the debug function
        debug_ai_assistant()
        
        return {'FINISHED'}

# 在register函数之前的类列表中添加新的操作符
classes = (
    AIMessageItem,
    # AIAssistantProperties, # 这个类通常单独注册
    AI_UL_messages,
    VIEW3D_PT_ai_assistant,
    VIEW3D_PT_ai_assistant_input,
    AI_OT_set_mode,
    AI_OT_send_message,
    AI_OT_clear_history,
    AI_OT_initialize,
    AI_OT_debug,
    AI_OT_refresh_history,  # 添加新的刷新历史操作符
    AI_OT_reload_config,  # 添加重新加载配置文件的操作符
    AI_OT_toggle_panel,  # 添加切换AI Assistant面板显示的操作符
    AI_OT_run_tests,  # 添加运行单元测试的操作符
)

# Handler to ensure the AI Assistant is properly initialized
@bpy.app.handlers.persistent
def ensure_ai_assistant_initialized(dummy):
    # Make sure we have a valid context
    if not hasattr(bpy, "context") or bpy.context is None:
        print("No valid context in handler", flush=True)
        return 0.1
    
    # Make sure we have a valid scene
    if not hasattr(bpy.context, "scene") or bpy.context.scene is None:
        print("No valid scene in handler", flush=True)
        return 0.1
    
    # Check if the property group is registered
    if not hasattr(bpy.context.scene, "ai_assistant"):
        # Register the property group if it's not already registered
        try:
            print("Attempting to register ai_assistant in handler...", flush=True)
            # Make sure the class is registered first
            if AIAssistantProperties not in bpy.utils.bl_rna_get_subclasses(bpy.types.PropertyGroup):
                bpy.utils.register_class(AIAssistantProperties)
            # Then register the property
            bpy.types.Scene.ai_assistant = bpy.props.PointerProperty(type=AIAssistantProperties)
            print("Successfully registered ai_assistant in handler", flush=True)
        except Exception as e:
            print(f"Error registering ai_assistant in handler: {e}", flush=True)
            # If we can't register it now, we'll try again later
            return 0.1
    
    return 1.0  # Check again in 1 second

def register():
    print("Registering AI Assistant...", flush=True)
    
    # First register the property class
    bpy.utils.register_class(AIAssistantProperties)
    
    # Then register the property group
    if not hasattr(bpy.types.Scene, "ai_assistant"):
        print("Creating ai_assistant property...", flush=True)
        bpy.types.Scene.ai_assistant = bpy.props.PointerProperty(type=AIAssistantProperties)
    
    # Register all other classes
    for cls in classes:
        if cls != AIAssistantProperties:  # Skip AIAssistantProperties as it's already registered
            bpy.utils.register_class(cls)
    
    # Register the handler to ensure the AI Assistant is properly initialized
    if ensure_ai_assistant_initialized not in bpy.app.handlers.depsgraph_update_post:
        bpy.app.handlers.depsgraph_update_post.append(ensure_ai_assistant_initialized)
    
    # Force initialization of the property group
    # This is important to ensure it's available immediately
    if hasattr(bpy.context, "scene") and bpy.context.scene is not None:
        if hasattr(bpy.context.scene, "ai_assistant"):
            print("Initializing ai_assistant properties...", flush=True)
            bpy.context.scene.ai_assistant.keep_open = False
            bpy.context.scene.ai_assistant.message = ""
            print("AI Assistant initialized successfully!", flush=True)
        else:
            print("WARNING: ai_assistant property not available on scene", flush=True)
    else:
        print("WARNING: No valid scene context available for initialization", flush=True)

def unregister():
    print("Unregistering AI Assistant...", flush=True)
    
    # Unregister the handler
    if ensure_ai_assistant_initialized in bpy.app.handlers.depsgraph_update_post:
        bpy.app.handlers.depsgraph_update_post.remove(ensure_ai_assistant_initialized)
    
    # Unregister all classes first
    for cls in reversed(classes):
        try:
            bpy.utils.unregister_class(cls)
        except Exception as e:
            print(f"Error unregistering {cls.__name__}: {e}", flush=True)
    
    # Unregister the property class last
    try:
        bpy.utils.unregister_class(AIAssistantProperties)
    except Exception as e:
        print(f"Error unregistering AIAssistantProperties: {e}", flush=True)
    
    # Remove the property group
    try:
        del bpy.types.Scene.ai_assistant
        print("AI Assistant property removed successfully", flush=True)
    except Exception as e:
        print(f"Error removing ai_assistant property: {e}", flush=True)

if __name__ == "__main__":
    register()
